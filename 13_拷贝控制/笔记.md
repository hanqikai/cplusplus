# 拷贝控制
* 拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。
* 拷贝和移动赋值运算符定义了一个将对象赋予同类型的另一个对象时做什么。
* 析构函数定义了当此类型对象销毁时做什么。
**这些操作为拷贝控制操作**
1. 拷贝构造函数
``` C++
class Foo {
public:
    Foo();  // 默认构造函数
    Foo(const Foo&);  // 拷贝构造函数
    // ...
};
```
* 拷贝构造函数的第一个参数必须是一个引用类型。
* 虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。
* 每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝：内置类型的成员则直接拷贝。
``` C++
class Sales_data {
public:
    // 与合成的拷贝构造函数的声明
    Sales_data(const Sales_data&);
private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
};
// 与Sales_data的合成的拷贝构造函数等价
Sales_data::Sales_data(const Sales_data &orig):
    bookNo(orig.bookNo),  // 使用string的拷贝构造函数
    units_sold(orig.units_sold),  // 使用orig.units_sold
    revenue(orig.revenue)  // 拷贝orig.revenue
    { }  // 空函数体
```

* 拷贝初始化
* 当使用直接初始化时，我们实际上时要求编译器使用普通的函数匹配来选择与我们的提供的参数最匹配的构造函数。当我们使用拷贝初始化时，要求编译器将右侧运算对象拷贝到正在创建的对象中。
``` C++
string dots(10, '.');  // 直接初始化
string s(dots);  // 直接初始化
string s2 = dots;  // 拷贝初始化
string null_book = "9-999-99999-9"  // 拷贝初始化
string nines = string(100, '9');  // 拷贝初始化
```
* 拷贝初始化在下列情况下也会发生

（1）将一个对象作为实参传递给一个非引用类型的形参
（2）从一个返回类型为非引用类型的函数返回一个对象
（3）用花括号列表初始化一个数组中的元素或一个聚合类中的成员

**拷贝构造函数自己的参必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但是为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。**
* 拷贝初始化的限制
explicit关键字的作用

（1）抑制构造函数定义的隐式转换
（2）为转换显式地使用构造函数
``` C++
vector<int> v1(10);  // 正确：直接初始化
vector<int> v2 = 10;  // 错误：接受大小参数的构造函数是explicit的
void f(vector<int>);  // f的参数进行拷贝初始化
f(10);  // 错误，不能用一个explicit的构造函数拷贝一个实参
f(vector<int>(10));  // 正确：从一个int直接构造一个临时vector
```

2. 拷贝赋值运算符

* 重载赋值运算符

重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为operator的函数。类似于任何其它函数，运算符函数也有一个返回类型和一个参数列表。
* 重载运算符的参数表示运算符的运算对象