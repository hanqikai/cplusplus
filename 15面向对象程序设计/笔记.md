1. OOP概述
* 面向对象程序设计的核心思想是数据抽象、继承和动态绑定。使用数据抽象。我们可以将类的接口与实现分离；使用继承，我们可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。
* 通过继承联系在一起的类构成一种层次关系。通常在层析关系的根部有一个基类，其它类则直接或者间接地从基类继承而来，这些继承得到的类称为派生类。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。
* 在C++语言中，基类将**类型相关的函数**与**派生类不做改变直接继承的函数**区分对待。对于某些函数，基类希望他的派生类各自定义适合自身的版本，此时基类就将这些函数声明成**虚函数**。因此，我们可以将Quote类编写成：
``` C++
class Quote {
public:
    std::string isbn() const;
    virtual double net_price(std::size_t n) const;
};
```
* 派生类必须通过使用类派生列表明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符：
``` C++
class Bulk_quote:public Quote {  // Bulk_quote继承了Quote
public:
    double net_price(std::size_t) const override;
};
```
因为Bulk_quote在它的派生类列表中使用了public关键字，因此我们完全可以把Bulk_quote的对象当成Quote的对象来使用。
* 派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上virtual关键字，但是并不是非得这么做。C++新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个override关键字。

* 通过使用动态绑定，我们能用同一段代码分别处理Quote和Bulk_quote的对象。
``` C++
double print_total(ostream &os, const Quote &item, size_t n) {
    // 根据传入item形参的对象类型调用Quote::net_price
    // 或者Bulk_quote::net_price
    double ret = item.net_price
    os << "ISBN: " << item.isbn()
       << "  # sold: " << n << "total due: " << ret << endl;
    return ret;
}
```
* 因为函数print_total的item形参是基类Quote的一个引用，所以我们既能使用基类Quote的对象调用该函数，也能使用派生类Bulk_quote的对象调用它：又因为print_total是使用引用类型调用net_price函数的，所以实际传入print_total的对象类型将决定到底执行net_price的哪个版本。
``` C++
print_total(cout, basic, 20);  // 调用Quote的net_price
print_total(cout, bulk, 20);  // 调用Bulk_quote的net_price
```
* 因为在上述过程中函数运行版本由实际参数决定，即在运行时选择函数的版本，所以动态绑定有时又被称为运行时绑定。
* 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

2. 定义基类和派生类
``` C++
class Quote {
public:
    Quote() = default;
    Quote(const std::string &book, double sales_price):bookNo(book), price(sales_price) { }
    std::string isbn() const { return bookNo; }
    // 返回给定数量的书籍的销售总额
    // 派生类负责改写并使用不同的折扣计算方法
    virtual double net_price(std::size_t n) const
    { return n * price; }
    virtual ~Quote() = default;  // 对析构函数进行动态绑定
private:
    std::string bookNo;  // 书籍的ISBN编号
protected:
    double price = 0.0;  // 代表普通状态下不打折的价格
};
```
* 在C++中，基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数：另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通常将其定义为虚函数。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。
* 任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。
* 如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。
* protected

派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望他的派生类有权访问该成员，同时禁止其他用户访问。protected访问运算符就是用来定义这些成员的。

* 定义派生类