1. 顺序容器
* 顺序列表容器类型

| 类型   |      特征      |
|:----------:|:-------------|
| vector |  可变大小数组。支持快速随机访问。在尾部之外的为止插入或者删除元素可能很慢 |
| deque | 双端队列。支持快速随机访问。在头尾为止插入/删除速度很快 |
| list | 双向链表。只支持双向顺序访问。在lis中任何位置及逆行插入/删除操作速度都很快 |
| forward_list | 单向链表。只支持单向顺序访问。在链表人格位置进行插入/删除操作速度都很快 |
| array | 固定大小数组。支持快速随机访问。不能添加或者删除元素 |
| string | 与vector相似的容器，但专门用于保存字符。随机访问快，在尾部插入/删除速度快 |

* 容器操作

| 类型别名   |      操作      |
|:----------:|:-------------|
| iterator | 此容器类型的迭代器类型 |
| const_iterator | 可以读取元素，但是不能修改元素的迭代器类型 |
| size_type | 无符号整数类型，足够保存此种容器类型最大金额能容器的大小 |
| difference_type | 带符号整数类型，足够保存两个迭代器之间的距离 |
| value_type | 元素类型 |
| reference | 元素的左值类型：与value_type含义相同 |
| const_reference | 元素的const左值类型(即，const value_type&) |

| 构造函数   |      操作      |
|:----------:|:-------------|
| C c | 默认构造函数，构造空容器(array) |
| C c1(c2); | 构造c2的拷贝c1 |
| C c(b, e); | 构造c，将迭代器b和e指定的范围内的元素拷贝到c |
| C c{a, b, c}; | 列表初始化c |

| 赋值与swap   |      操作      |
|:----------:|:-------------|
| c1 = c2 | 将c1中的元素替换为c2中的元素 |
| c1 = {a, b, c} | 将c1中的元素替换为列表中元素 |
| a.swap(b) | 交换a和b的元素 |
| swap(a, b) | 与a.swap(b)等价 |

| 大小   |      操作      |
|:----------:|:-------------|
| c.size() | c中元素的数目 |
| c.max_size() | c可以保存的最大元素数目 |
| c.empty() | 若c中存储了元素，返回false，否则返回true |

| 添加/删除元素   | 操作 |
|:----------:|:-------------|
| c.insert(args) | 将args中的元素拷贝进c |
| c.emplace(inits) | 使用inits构造c中的一个元素 |
| c.erase(args) | 删除args指定的元素 |
| c.clear() | 删除c中的所有元素，返回void |

| 关系运算符   | 操作 |
|:----------:|:-------------|
| ==, != | 所有容器都支持相等(不等)运算符 |
| <, <=, >, >= | 关系运算符(无序关联容器不支持) |

| 获取迭代器   | 操作 |
|:----------:|:-------------|
| c.begin(), c.end() | 返回指向c的首元素和尾元素之后 |
| c.cbegin(), c.cend() | 返回const_iterator |

| 反向容器的额外成员(不支持forward_list)   | 操作 |
|:----------:|:-------------|
| reverse_iterator | 按逆序寻址元素的迭代器 |
| const_reverse_iterator | 不能修改元素的逆序迭代器 |
| c.rbegin(), c.rend() | 返回指向c的尾元素和首元素之前位置的迭代器 |
| c.crbegin(), c.crend() | 返回const_reverse_iterator |

2. 迭代器
* 一个迭代器范围由一堆迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。这两个迭代器哦通常被称为begin和end，或者是first和last，他们标记了容器中元素的一个范围。虽然第二个迭代器通常被称为last，但是这种叫法有误导，因为**第二个迭代器从来都不会指向范围内的最后一个元素，而是指向尾元素之后的位置**。这种元素范围被称为左闭合区间，其标准数学描述为$ [begin, end) $，表示范围自begin开始，于end之前结束。迭代器begin和end必须指向相同的容器。end可以和begin指向相同的位置，但是不能指向begin之前的位置。
3. 容器定义和初始化

![容器定义和初始化](init.png)

* 将一个容器初始化为另一个容器的拷贝
``` C++
// 每个容器有三个元素，用给定的初始化器进行初始化
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};

list<string> list2(authors);  // 正确：类型匹配
deque<string> authList(authors);  // 错误：容器类型不匹配
vector<string> words(articles);  // 错误：容器类型必须匹配

// 正确：可以将const char*元素转换为string
forward_list<string> words(articles.begin(), articles.end());
/*
接受两个迭代器参数的构造函数用这两个迭代器表示我们想要拷贝的一个元素范围。两个迭代器分别标记想要拷贝的第一个元素和尾元素之后的位置。新容器的大小与范围中元素的数目相同。新容器中的每个元素都用范围中对应元素的值进行初始化。
*/

//拷贝元素，直到(但不包括)it指向的元素
deque<string> authList(authors.begin(), it);
```
* 列表初始化
``` C++
//每个容器有三个元素，用给定的初始化器进行初始化
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
```
* 与顺序容器大小相关的构造函数
``` C++
vector<int> ivec(10, -1); // 10个int元素，每个都初始化为-1
list<string> svec(10, "hi!"); // 10个strings; 每个都初始化为"hi!"
forward_list<int> ivec(10); // 10个元素，每个都初始化为0
deque<string> svec(10);  // 10个元素，每个都是空string
```
* 标准库array具有固定大小，当定义一个array时，除了指定元素类型，还要指定容器大小：
``` C++
array<int, 42>  // 类型为：保存42个int的数组
array<string, 10>  // 类型为：保存10个string的数组
array<int, 10>::size_type i;  // 数组类型包括元素类型和大小
array<int>::size_type j;  // 错误：array<int>不是一个类型
array<int, 10> ial;  // 10个默认初始化的int
array<int, 10> ia2 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};  // 列表初始化
array<int, 10> ia3 = {42};  // ia3[0]为42，剩余元素为0

int digs[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int cpy[10] = digs;  // 错误：内置数组不支持拷贝或赋值
array<int, 10> digits = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
array<int, 10> copy = digits;  // 正确：只要数组类型匹配即合法
```
* 容器赋值运算
![容器赋值运算](assign.png)
``` C++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle;  // 错误：容器类型不匹配

// 正确，可以将const char* 转换为string
names.assign(oldstyle.cbegin(), oldstyle.cend());

// 等价于slist1.clear();
//后跟slist1.insert(slist1.begin(), 10, "Hiya!");
list<string> slist1(1);  // 一个元素，为空string
slist1.assign(10, "Hiya!");  // 10个元素，每个都是"Hiya!"
```
4. 顺序容器操作
![向顺序容器添加元素](sequence_add.png)
``` C++
void pluralize(size_t cnt, string &word) {
    if (cnt > 1)
        word.push_back('s');  // 等价于word += 's'
}

list<int> ilist;
// 将元素添加到ilist开头
for(size_t ix = 0; ix != 4; ++ix)   ilist.push_front(ix);
```
* vector不支持push_front
* 每个insert函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能只想容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能，所以insert函数将元素插入到迭代器所指定的位置之前
``` C++
slist.insert(iter, "Hello!");  // 将"Hello!"添加到iter之前的位置
```
* 虽然某些容器不支持push_front操作，但是他们对于insert操作并无类似的限制，因此我们可以将元素插入到容器的开始位置，而不必担心容器是否支持push_front.
``` C++
vector<string> svec;
list<string> slist;

// 等价于调用slist.push_front("Hello!");
slist.insert(slist.begin(), "Hello!");

//vector不支持push_front，但是我们可以插入到begin()之前
svec.insert(svec.begin(), "Hello!");
```
* 插入范围内元素

insert函数还可以接受更多的参数，其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定元素初始化。
``` C++
svec.insert(svec.end(), 10, "Anna");  // 将10个元素插入到svec的末尾，并将所有元素都初始化为string "Anna"

//接受一对迭代器或者一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前
vector<string> v = {"quasi", "simba", "frollo", "scar"};
//将v的最后两个元素添加到slist的开始位置
slist.insert(slist.begin(), v.end() - 2, v.end());
slist.insert(slist.end(), {"these", "words", "will", "go", "at", "the", "end"});

// 运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器
slist.insert(slist.begin(), slist.begin(), slist.end());
```
* 使用insert的返回值
``` C++
list<string> lst;
auto iter = lst.begin();
while (cin >> word) 
    iter = lst.insert(iter, word);  // 等价于调用push_front
/*
在循环之前，我们将iter初始化为lst.begin()。第一次调用insert会将我们刚刚读入的string插入到iter所指向的元素之前的位置。insert返回的迭代器恰好指向这个新元素。我们将此迭代器赋予iter病重复循环，读取下一个单词。只要继续有单词读入，每一步while循环就会将一个新元素插入到iter之前，并将iter改编为新加入元素的位置。此元素为（新的）首元素。因此，每部循环将一个新元素插入到list首元素之前的位置。
*/
```

* 使用emplace操作

当条用push或者insert成员函数时，我们将元素类型的对象传递给他们，这些对象被拷贝到容器中，而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。
5. 访问元素
``` C++
// 在解引用一个迭代器或调用front或back之前检查是否有元素
if (!c.empty()) {
    // val和val2是c中第一个元素值的拷贝
    auto val = *c.begin(), val2 = c.front();
    // val3和val4是c中最后一个元素值的拷贝
    auto last = c.end();
    auto val3 = *(--last);  // 不能递减forward_list迭代器
    auto val4 = c.back();  // forward_list不支持
}
// 此程序用两种不同方式来获取c中的首元素和尾元素的应用。
```
* 在顺序容器中访问元素的操作

注：at和下标操作只适用于string、vector、deuqe和array，back不适用于forward_list
| 访问元素的操作 | 含义 |
|:--------:|:--------:|
| c.back() | 返回c中尾元素的引用。若c为空，函数行为未定义 |
| c.front | 返回c中首元素的引用。若c为空，函数行为未定义 |
| c[n] | 返回c中下标为n的元素的引用，n是一个无符号整数。若n >= c.size(), 则函数行为未定义 |
| c.at(n) | 返回下标为n的元素的引用。如果下标越界，则抛出out_of_range异常 |
* 在容器中访问元素的成员函数（即，front、back、下标和at）返回的都是引用。如果容器是一个const对象，则返回值是const的引用。如果容器不是const的，则返回值是普通引用，我们可以用来改变元素的值。
``` C++
if (!c.empty()) {
    c.front() = 42;  // 将42赋予c中的第一个元素
    auto &v = c.back();  // 获得指向最后一个元素的引用
    v = 1024;  // 改变c中的元素
    auto v2 = c.back();  // v2不是一个引用，它是c.back()的一个拷贝
    v2 = 0; // 未改变c中的元素
}
```
6. 删除元素
容器中也有多种删除元素的方式。
* forward_list有特殊版本的erase，forward_list不支持pop_back; vector和string不支持pop_front

| 删除元素的方法 | 含义 |
| :----------: | :----------: |
| c.pop_back() | 删除c中尾元素。若c为空，则函数行为未定义。函数返回void |
| c.pop_front() | 删除c中首元素。若c为空，则函数行为未定义。函数返回void |
| c.erase(p) | 删除迭代器p所指定的元素，返回一个指向被删元素之后元素的迭代器，若p指向尾元素，则返回尾后迭代器。若p是尾后迭代器，则函数行为未定义 | 
| c.erase(b, e) | 删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若e本身就是尾后迭代器，则函数也返回尾后迭代器 |
| c.clear() | 删除c中的所有元素。返回void |

* vector, string不支持pop_front
* pop_back(), pop_front()这些操作返回void。
* 成员函数erase从容器中指定位置删除元素。我们可以删除有一个迭代器指定的单个元素，也可以删除有一对迭代器指定的范围内的所有元素。两种形式的erase都返回指向删除的（最后一个）元素之后的位置的迭代器。
``` C++
list<int> lst = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto it = lst.begin();
while (it != lst.end())
    if (*it % 2)  // 若元素为奇数
        it = lst.erase(it);  // 删除此元素
    else
        ++it;
``` 

* 删除多个元素
``` C++
// 删除两个迭代器表示的范围内的元素
// 返回指向最后一个被删元素之后位置的迭代器
elem1 = slist.erase(elem1, elem2);  // 调用后，elem1 == elem2

slist.clear();  // 删除容器中所有元素
slist.erase(slist.begin(), slist.end());  // 等价调用
```
* 特殊的forward_list操作
![forward_list中的添加或者删除操作](forward_list.png)

``` C++
//改写从list中删除奇数元素的循环程序，将其改为从foorward_list中删除元素
forward_list<int> flst = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
auto prev = flst.before_begin();  // 表示flst的“首前元素”
auto curr = flst.begin();  // 表示flst中的第一个元素
while (curr != flst.end()) {  // 仍有元素需要处理
    if(*curr % 2)  // 若元素是奇数
       curr = flst.erase_after(prev);  // 删除它并移动curr
    else {
        prev = curr;  // 移动迭代器curr，指向下一个元素, prev指向curr之前的元素
        ++curr;  
    }
}

```