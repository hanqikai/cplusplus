# 模板和泛型编程
1. 定义模板
* 我们可以定义一个通用的模板，而不是为每个类型都定义一个模板函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板版本可能像下面这样：
``` C++
template <typename T>
int compare(const T &v1, const T &v2) {
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```
* 模板定义以关键字template开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表，用小于号（<）和大于号（>）包围起来。
* 在模板定义中，模板参数列表不能为空。模板参数表示在类或函数中用到的类型或值。当使用模板时，我们指定模板实参，将其绑定到模板参数上。

* 实例化函数模板

当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板类型。即，当我们调用compare时，编译器使用实参的类型来确定绑定到模板参数T的类型。例如，在下面的调用中：
``` C++
cout << compare(1, 0) << endl;  // T为int
```
实参类型是int。编译器会推断出模板实参为int，并将它绑定到模板参数T。

* 模板类型参数

我们的compare函数有一个模板类型参数。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：
``` C++
// 正确，返回类型和参数类型相同
template <typename T> T foo(T* p) {
    T tmp = *p;  // tmp的类型将是指针p指向的类型
    //...
    return tmp;
}
```
类型参数前必须使用关键字class或typename：
``` C++
// 错误：U之前必须加上class或typename
template <typename T, U> T calc(const T&, const U&);
```
* 在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以同时使用这两个关键字：
``` C++
// 正确，在参数模板列表中，typename和class没有什么不同
template <typename T, class U> calc (const T&, const U&);
```

* 非类型模板参数
除了定义类型参数，还可以在模板中定义非类型参数。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名字而非关键字class或typename来指定非类型参数。
``` C++
template <unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M]) {
    return strcmp(p1, p2);
}
```

当我们调用这个版本的compare时：compare("hi", "mom")，编译器会使用字面常量的大小来代替N和M，从而实现实例化模板。编译器会在一个字符串常量的末尾插入一个空字符作为终结符，因此编译器会实例化出如下版本：
``` C++
int compare(const char (&p1)[3], const char (&p2)[4])
```
* 非类型模板参数的模板实参必须是常量表达式
* inline和constexpr的函数模板

函数模板可以声明为inline或constexpr的，如同非模板函数一样。inline或constexpr说明符放在模板参数列表之后，返回类型之前：
``` C++
// 正确：inline说明符跟在模板参数列表之后
template <typename T> inline T min(const T&, const T&);
// 错误：inline说明符的位置不正确
inline template <typename T> T min(const T&, const T&);
```
* 编写泛型代码的两个重要原则：

（1）模板中的函数参数是const的引用。
（2）函数体中的条件判断仅使用<比较运算

* 模板编译
当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。这一特性影响了我们如何组织代码以及错误合适被检测到。
* 我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。模板的头文件通常既包括声明也包括定义。函数模板和类模板成员函数的定义通常放在头文件中。

2. 类模板
* 编译器不能为类模板推断模板参数类型。我们必须在模板名后的尖括号中提供额外信息——用来代替模板参数的模板实参列表。
