# 模板和泛型编程
1. 定义模板
* 我们可以定义一个通用的模板，而不是为每个类型都定义一个模板函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。compare的模板版本可能像下面这样：
``` C++
template <typename T>
int compare(const T &v1, const T &v2) {
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```
* 模板定义以关键字template开始，后跟一个模板参数列表，这是一个逗号分隔的一个或多个模板参数的列表，用小于号（<）和大于号（>）包围起来。
* 在模板定义中，模板参数列表不能为空。模板参数表示在类或函数中用到的类型或值。当使用模板时，我们指定模板实参，将其绑定到模板参数上。

* 实例化函数模板

当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板类型。即，当我们调用compare时，编译器使用实参的类型来确定绑定到模板参数T的类型。例如，在下面的调用中：
``` C++
cout << compare(1, 0) << endl;  // T为int
```
实参类型是int。编译器会推断出模板实参为int，并将它绑定到模板参数T。

* 模板类型参数

我们的compare函数有一个模板类型参数。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换：
``` C++
// 正确，返回类型和参数类型相同
template <typename T> T foo(T* p) {
    T tmp = *p;  // tmp的类型将是指针p指向的类型
    //...
    return tmp;
}
```
类型参数前必须使用关键字class或typename：
``` C++
// 错误：U之前必须加上class或typename
template <typename T, U> T calc(const T&, const U&);
```