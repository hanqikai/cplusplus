1. 程序运行的过程
    * 使用文本编辑器编写程序，并将其保存到文件中，这个文件就是程序的源代码。
    * 编译源代码。这意味着运行一个程序，将源代码翻译为主机使用的内部语言——机器语言。包含了翻译后的程序的文件就是程序的目标代码。
    * 将目标代码与其他代码连接起来。例如，C++程序通常使用库。C++库包含一系列计算机例程（被称为函数）的目标代码，这些函数可以执行诸如在屏幕上显示信息或者计算平方根等任务。链接指的是将目标代码同时使用的函数的目标代码以及一些标准的启动代码（startup code）组合起来，生成程序的运行阶段版本。包含该最终产品的文件称为可执行代码。
2. 从命令行运行编译器的语句：`$ g++ -o prog1 -std=c++11 xxxx.cpp`
    * 此处，$是系统提示符，-o prog1是编译器参数，指定了可执行文件的文件名。在不同的操作系统中，此命令生成一个名为prog1或者prog1.exe的可执行文件。在UNIX系统中，可执行文件没有后缀；在Windows系统中，后缀为.exe。如果省略了`-o prog1`参数，在UNIX系统中编译器会生成一个名为a.out的可执行文件，在windows系统中会生成一个a.exe的可执行文件。`-std=c++11`参数是打开C++11的支持。
3. `std::cout << std::endl;`
    * 该输出运算符打印endl，这是一个北称为操纵符的特殊值。写入endl的效果是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷新到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。
    * 前缀std::指出名字cout和endl是定义在名为std的命名空间(namespace)中的。命名空间可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突。标准库定义的所有名字都在命名空间std中。
    * 通过使用作用域运算符::，来指出我们想使用定义在命名空间std中的名字cout。
4. 注释
    * 单行注释：以双斜线（//）开始，以换行符结束
    * 界定符对注释：（/* 和 */），以 /*开始，以 */结束，
    * 注释对/* */不能嵌套
5. 读取数量不定的输入数据
    * while(std::cin >> value)
    * while循环条件的求值就是执行表达式(std::cin >> value)，此表达式从标准输入读取下一个数，保存在value中。输入运算符返回其左侧运算对象(std::cin)。因此，此循环条件实际上检测的是std::cin。 当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流时有效的，即流未遇到错误，那么检测成功。当遇到文件结束符(end-of-file)，或者遇到一个无效输入时，istream对象的状态会变成无效。处于无效状态的istream对象会使条件变为假。
    * 当从键盘向程序输入数据时，对于如何指出文件结束，不同OS有不同的约定。Windows：Ctrl+Z; UNIX：Ctrl+D。
6. 类
    * 成员函数是定义为类的一部分的函数，有时候也被称为方法(method)。
    * `item1.isbn()`使用点运算符(.)来表达我们需要“名为item1的对象的isbn成员”。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。
    * 我们使用调用运算符（()）来调用一个函数。调用运算符是一对花括号，里面放置实参列表(可能为空)。因此，item.isbn()调用名为item1的对象的成员函数isbn.
7. 隐形参数
    ``` C++
    #include <iostream>
    using namespace std;
    // argc: argument count
    // argv: argument vector
    int main(int argc, char** argv){
        cout << argc << endl;
        for(int i = 0; i < argc; i++){
            cout << argv[i] << endl;
        }
        return 0;
    }
    ```
    * 程序在运行时，argv中的第一个参数是程序名，其余的参数是我们传进来的一系列参数。









