# 泛型算法
**顺序容器只定义了很少的操作，在多数的情况下，我们可以添加和删除元素、访问首尾元素、确定容器是否为空等。对于查找特定元素、替换或删除一个特定值、重排元素顺序等，标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法（generic algorithm）:称他们为“算法”，是因为他们是现在一些经典算法的公共接口，如排序和搜索：称它们是“泛型的”，是因为它们可以用于不同类型的元素和多重容器类型（不仅包括标准库类型，如vector和list，还包括内置的数组类型），还能用于其它类型的序列。**
1. find函数
``` C++
int val = 42;  // 我们将要查找的值
// 如果在vec中找到想要的元素，则会犯结果指向它，否则返回结果为vec.cend()
auto result = find(vec.cbegin(), vec.cend(), val);
//报告结果
cout << "The value " << val
     << (result == vec.cend()
        ? " is not present" : " is present") << endl;

// 用find在一个string的list中查找一个给定值
string val = "a value";  // 我们要查找的值
// 此调用在list中查找string元素
auto result = find(lst.cbegin(), lst.cend(), val);

// 类似的， 我们可以利用find在数组中查找值
int ia[] = {27, 210, 12, 47, 109, 83};
int val = 83;
int *result = find(begin(ia), end(ia), val);

// 还可以在序列的子范围中查找
// 在从ia[1]开始，直至（但不包含）ia[4]的范围内查找元素
auto result = find(ia + 1, ia + 4, val);
```
2. 只读算法
* 算法智慧读取其输入范围内的元素，而从不改变元素。find就是这样一种算法，count函数也是如此。
* 另一个只读算法是accumulate，它定义在头文件numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。假定vec是一个整数序列，则：
``` C++
// 对vec中的元素求和，和的初始值是0
int sum = accumulate(vec.begin(), vec.end(), 0);
```
* 由于string定义了+运算符，所以我们可以通过调用accumulate来将vector中所有string元素连接起来：
``` C++
string sum = accumulate(v.cbegin(), v.cend(), string(""));
// 将v中每个元素连接到一个string上，该string初始时为空串。

//注：将空串当作一个字符字面值传递给第三个参数是不可以的，会导致一个编译错误
// 错误：const char*上没有定义+运算符
string sum = accumulate(v.cbegin(), v.cend(), "");
// 如果我们传递了一个字符串字面值，用于保存和的对象的类型将是const char*。
```
* 对于只读取而不改变元素的算法，通常最好使用cbegin()和cend(); 如果计划使用算法返回的迭代器来改变元素的值，就需要使用begin()和end()的结果作为参数。

* equal算法

equal算法用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有元素都相等，则返回true，否则返回false。此算法接受三个迭代器：前两个表示第一个序列中的元素范围，第三个表示第二个序列的首元素：
``` C++
// roster2中的元素数目应该至少与roster1一样多
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
```
3. 写容器元素的算法
* fill算法

fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。
``` C++
fill(vec.begin(), vec.end(), 0);  // 将每个元素设置为0

// 将容器中的一个子序列设置为0
fill(vec.begin(), vec.begin() + vec.size() / 2, 10);
```
* fill_n函数

函数fill_n接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。
``` C++
vector<int> vec;  // 空vector
// 使用vec，赋予它不同值
fill_n(vec.begin(), vec.size(), 0);  // 将所有元素重置为0

//不可以在空容器上调用fill_n
// 错误写法：
vector<int> vec;  // 空vector
fill_n(vec.begin(), 10, 0);
// 我们指定了要写入10个元素，但是vec中并没有元素——它是空的。
```
* back_inserter

back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算会调用push_back将一个具有给定值的元素添加到容器中：
``` C++
vector<int> vec;  // 空向量
auto it = back_inserter(vec);  // 通过它赋值会将元素添加到vec中
*it = 42;

// 我们常常使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。
vector<int> vec;  // 空向量
// back_inserter创建一个插入迭代器，可用来向vec添加元素
fill_n(back_inserter(vec), 10, 0);  // 添加10个元素到vec
```
在每步迭代中，fill_in向给定序列的一个元素赋值。由于我们传递的参数是back_inserter返回的迭代器，因此每次赋值都会在vec上调用push_back。最终，这条fill_in调用语句向vec的末尾添加了10个元素，每个元素的值都是0

4. 拷贝算法
* 拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给copy目的序列至少要包含与输入序列一样多的元素。
``` C++
int a1[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int a2[sizeof(a1) / sizeof(*a1)];  // a2与a1大小一样
// ret指向拷贝到a2的尾元素之后的位置
auto ret = copy(begin(a1), end(a1), a2);  // 把a1的内容拷贝给a2
```
* copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的值。

* 注：多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但是不会将他们放置在输入序列的末尾，而是创建一个新序列保存这些结果。
``` C++
// 将所有的值为0的元素改为42
replace(ilist.begin(), ilist.end(), 0, 42);
//此调用将序列中所有的0都替换为42。如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置。


// 使用back_inserter按需要增长目标序列
replace_copy(ilist.cbegin(), ilist.cend(), back_inserter(ivec), 0, 42);
// 此调用后，ilist并未改变，ivec包含ilist的一份拷贝，不过原来在ilist中值为0的元素在ivec中都变为42。
```
* 消除重复单词

为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分。
``` C++
void eliDups(vector<string> &words) {
    // 按照字典排序words，以便查找重复单词
    sort(words.begin(), words.end());
    // unique重排输出范围，使得每个单词只出现一次
    // 排列在范围的前部，返回指向不重复区域之后一个位置的迭代器
    auto end_unoque = unique(words.begin(), words.end());
    // 使用向量操作erase删除重复单词
    words.erase(end_unique, words.end());
}
```
* sort算法接受两个迭代器，表示要排序的元素范围，我蛮排序整个vector。完成sort后，words的顺序如下所示：
![after_sort](after_sort.png)
* words排序完毕后，我们希望将每个单词都只保存一次。unique算法重新输入序列，将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。调用unique后，vector变为：
![after_unique](after_unique.png)
* words的大小并未改变，它仍然有10个元素。但是这些元素的顺序被改变了——相邻的重复元素被“删除”了。它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。unique返回的迭代器指向最后一个不重复元素之后的位置。
