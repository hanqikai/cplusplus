1. 基本概念
* 重载的运算符是具有特殊名字的函数：他们的名字由关键字operator和气候要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。
* 重载运算符函数的参数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。
* 除了重载的函数条用运算符operator()之外，其它重载运算符不能含有默认实参。
* 当一个重载的运算符是成员函数时，this绑定到左侧对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。
* 当运算符作用域内置的运算对象时，我们无法改变该运算符的含义。
![可以重载的运算符](op.png)

* 直接调用一个重载的运算符函数
``` C++
// 一个非成员运算符函数的等价调用
data1 + data2;  // 普通的表达式
operator+(data1, data2);  // 等价的函数调用
```

* 像调用其它成员函数一样显式地调用成员运算符函数。具体做法是，首先指定运行函数的对象（或指针）的名字，然后使用点运算符（或箭头运算符）访问希望调用的函数：
``` C++
data1 += data;  // 基于“调用”的表达式
data1.operator+=(data2);
```
* 这两条语句都调用了成员函数operator+=，将this绑定到data1的地址、将data2作为实参传入了函数。

* 一般不重载逗号运算符、取地址运算符、逻辑与和逻辑或运算符。

* 赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。

* 重载输出运算符

``` C++
ostream &operator<<(ostream &os, const Sales_data &item) {
    os << item.isbn() << " " << item.units_sold << " "
       << item.revenue << " " << item.avg_price();
    return os;
}
```
* 重载输入运算符
``` C++
istream &operator>> (istream &is, Sales_data &item) {
    double price;
    is >> item.bookNo >> item.units_sold >> price;
    if (is) item.revenue = item.units_sold * price;
    else item = Sales_data();
    return is;
}
```

* 重载算术运算符
``` C++
Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs) {
    Sales_data sum = 1hs;
    sum += rhs;
    return sum;
}
```

* 重载相等运算符
``` C++
bool operator==(const Sales_data &lhs, const Sales_data &rhs) {
    return lhs.isbn() == rhs.isbn() && 
           lhs.units_sold == rhs.units_sold && 
           lhs.revenue == rhs.revenue;

}
bool operator!=(const Sales_data &lhs, const Sales_data &rhs) {
    return !(lhs == rhs);
}

```
